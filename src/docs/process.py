# Copyright (c) Microsoft. All rights reserved.

import argparse
import html
import docutils.frontend
import docutils.nodes
import docutils.parsers.rst
import docutils.utils
import glob
import json
import os.path
import re
import subprocess
import sys

from pathlib import Path

CMAKE_REPO_URL = 'https://github.com/Microsoft/CMake.git'
CMAKE_COMMAND_DIR = 'help/command'
CMAKE_VARIABLE_DIRS = [
    'help/variable',
    'help/prop_cache',
    'help/prop_dir',
    'help/prop_gbl',
    'help/prop_inst',
    'help/prop_sf',
    'help/prop_test',
    'help/prop_tgt']

RESX_FILE_TEMPLATE = """<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- This file is autogenerated by process.py based on CMake documentation -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
{}
</root>"""

RESX_ITEM_TEMPLATE = """  <data name="{}" xml:space="preserve">
    <value>{}</value>
  </data>
"""

# Helper visitor to accumulate all text from literal blocks in a document.
class SyntaxExtractorVisitor(docutils.nodes.GenericNodeVisitor):
    def __init__(self, document):
        self.syntax_examples = []
        docutils.nodes.GenericNodeVisitor.__init__(self, document)

    def visit_literal_block(self, node):
        self.syntax_examples.append(node.astext())

    def default_visit(self, node):
        pass

def clean_command_syntax(syntax):
    # Remove the language marker at the beginning of the literal block.
    result = syntax.replace('.. code-block:: cmake', '')

    # Remove the signature marker at the beginning of the literal block
    result = result.replace('.. signature::', '')

    # Remove any trailing comments because they won't format well in a single
    # line for quick info.
    result = re.sub(r'#.*', '', result)

    # Syntax examples often span multiple lines. Remove line breaks and extra
    # whitespace.
    result = re.sub(r'\s+', ' ', result.strip())

    # Remove extra whitespace between adjacent open or close punctuation. This
    # can happen when trailing comments are removed.
    result = re.sub(r'([\(\<\[\{])\s+([\(\<\[\{])', r'\1\2', result)
    result = re.sub(r'([\)\>\]\}])\s+([\)\>\]\}])', r'\1\2', result)

    return result

def find_first_paragraph(section, index=1):
    while section[index].tagname != 'paragraph':
        index += 1
    return section[index].astext()

def clean_description(description):
    # Descriptions sometimes have hard line breaks. Remove them.
    result = re.sub(r'\s+', ' ', description.strip())

    # Try to strip out broken text roles from the description.
    result = re.sub(
        r':\w+:`([\w\s\-;<>\(\)]+?)([\(<][\w\d\s]+[\)>])?`', r'\1', result)

    # Other manual fixups
    result = result.replace(';-list', 'Semicolon-separated list')
    return result

def parse_file(path):
    with open(path) as fileobj:
        default_settings = docutils.frontend.OptionParser(
            components=(docutils.parsers.rst.Parser,)).get_default_values()
        document = docutils.utils.new_document(fileobj.name, default_settings)
        parser = docutils.parsers.rst.Parser()
        parser.parse(fileobj.read(), document)

        # Bail out if this document has multiple sections.
        assert len(document.children) == 1
        assert document[0].tagname == 'section'

        # Expect documentation to consist of a brief summary followed by the
        # syntax of the command.
        section = document[0]
        assert len(section.children) >= 2
        assert section[0].tagname == 'title'
        name = section[0].astext()

        description = find_first_paragraph(section)
        description = clean_description(description)

        return (document, name, description)

def parse_command_file(path):
    document, name, description = parse_file(path)

    syntax_visitor = SyntaxExtractorVisitor(document)
    document.walk(syntax_visitor)
    syntax_examples = syntax_visitor.syntax_examples
    assert len(syntax_examples) >= 1

    # Remove any extracted literal blocks that don't actually start with the
    # command name. Sometimes the docs contain other examples, like invoking
    # cmake on the command line.
    syntax_examples = [
        clean_syntax for clean_syntax in (
            clean_command_syntax(syntax) for syntax in syntax_examples)
        if clean_syntax.startswith(name)]
    assert len(syntax_examples) >= 1

    return (name, description, syntax_examples)

def parse_variable_file(path):
    _, name, description = parse_file(path)
    return (name, description)

def parse_all(root_paths, parser, fallbacks):
    result = []
    for root_path in root_paths:
        for path in glob.glob(os.path.join(root_path, '*.rst')):
            try:
                parse_result = parser(path)
            except:
                key = Path(path).stem
                if key in fallbacks:
                    parse_result = tuple(fallbacks[key])
                else:
                    sys.exit('Error parsing {}'.format(path))
            result.append(parse_result)
    return result

def parse_all_commands(root_path, fallbacks):
    return parse_all([root_path], parse_command_file, fallbacks)

def parse_all_variables(root_paths, fallbacks):
    return parse_all(root_paths, parse_variable_file, fallbacks)

def output_resx(descriptions):
    items = ''.join(RESX_ITEM_TEMPLATE.format(n, d) for n, d in descriptions)
    text = RESX_FILE_TEMPLATE.format(items)
    with open('IntelliSenseResources.resx', 'w') as fileobj:
        fileobj.write(text)

def generate_loc_key(name):
    return 'loc_' + re.sub(r'\W', '', name.lower())

def clone_repo(url, reporoot):
    result = subprocess.call("git clone --depth 1 {} {}".format(url, reporoot))
    return result == 0

def main():
    argparser = argparse.ArgumentParser()
    argparser.add_argument('--repo', action='store', default='cmake',
        help='use path specified for CMake repo')
    argparser.add_argument('--clone', action='store_true',
        help='clone the CMake repo before processing')
    argparser.add_argument('--dryrun', action='store_true',
        help='process, but do not generate output files')
    args = argparser.parse_args()

    if (args.clone and not clone_repo(CMAKE_REPO_URL, args.repo)):
        sys.exit('Error cloning CMake repo')

    with open('fallbacks.json', 'r') as fallbacks_file:
        fallbacks = json.load(fallbacks_file)

    commands = parse_all_commands(os.path.join(args.repo, CMAKE_COMMAND_DIR), fallbacks)
    variables = parse_all_variables((os.path.join(args.repo, d) for d in CMAKE_VARIABLE_DIRS), fallbacks)

    if (args.dryrun):
        print('Skipping output because dryrun is enabled')
        return

    resx_descriptions = []
    names = []
    commands_json = {}
    variables_json = {}

    for name, description, syntax_examples in commands:
        # CMake commands are case insensitive, so key off the lowercase version
        key = name.lower()
        if key in commands_json:
            continue

        loc_key = generate_loc_key(name)
        resx_descriptions.append((loc_key, html.escape(description)))
        names.append(name)

        commands_json[key] = {
            'name': name,
            'description': loc_key,
            'syntax_examples': syntax_examples
        }

    for name, description in variables:
        if name in variables_json:
            continue
        loc_key = generate_loc_key(name)
        resx_descriptions.append((loc_key, html.escape(description)))
        names.append(name)
        variables_json[name] = {
            'name': name,
            'description': loc_key
        }

    output_resx(resx_descriptions)

    with open('commands.json', 'w') as commands_file:
        json.dump(commands_json, commands_file)

    with open('variables.json', 'w') as variables_file:
        json.dump(variables_json, variables_file)

    with open('names_allowlist.txt', 'w') as names_file:
        names_file.write('\n'.join(names))

if __name__ == '__main__':
    main()